#!/usr/bin/env python3

"""
文件管理器模块
负责配置文件的创建、备份、更新等操作
"""

import os
import sys
from pathlib import Path
from typing import List, Optional

# 添加父目录到路径以导入common模块
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

try:
    from common import log_info, log_warn, log_error, log_success
except ImportError:
    # 如果无法导入，提供简单的日志函数
    def log_info(msg): print(f"[INFO] {msg}")
    def log_warn(msg): print(f"[WARN] {msg}")
    def log_error(msg): print(f"[ERROR] {msg}")
    def log_success(msg): print(f"[SUCCESS] {msg}")


class FileManager:
    """配置文件管理器"""

    def __init__(self):
        # 配置目录和文件路径
        self.custom_dir = Path.home() / ".oh-my-zsh" / "custom"
        self.modules_dir = self.custom_dir / "modules"
        self.debug_dir = self.custom_dir / "debug"
        self.main_config_file = self.custom_dir / "shell-tools-main.zsh"
        self.old_config_file = Path.home() / ".shell-tools-config.zsh"
        self.zshrc_file = Path.home() / ".zshrc"

    def create_directories(self) -> bool:
        """创建必要的目录结构"""
        try:
            self.custom_dir.mkdir(parents=True, exist_ok=True)
            self.modules_dir.mkdir(parents=True, exist_ok=True)
            self.debug_dir.mkdir(parents=True, exist_ok=True)
            log_info(f"创建目录结构: {self.custom_dir}")
            return True
        except Exception as e:
            log_error(f"创建目录失败: {str(e)}")
            return False

    def handle_legacy_config(self) -> bool:
        """处理旧版配置文件的迁移"""
        if self.old_config_file.exists():
            log_warn(f"检测到旧版配置文件: {self.old_config_file}")
            log_info("新版本使用模块化配置，旧文件将被备份")

            # 备份旧文件
            backup_file = self.old_config_file.with_suffix('.zsh.backup')
            try:
                self.old_config_file.rename(backup_file)
                log_success(f"旧配置文件已备份到: {backup_file}")
            except Exception as e:
                log_warn(f"备份旧配置文件失败: {str(e)}")

        return True

    def write_file(self, file_path: Path, content: str) -> bool:
        """写入文件内容"""
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            return True
        except Exception as e:
            log_error(f"写入文件 {file_path} 失败: {str(e)}")
            return False

    def write_module_file(self, module_file: str, description: str,
                         required_tools: List[str], dependencies: List[str],
                         content: str) -> bool:
        """写入模块文件"""
        module_path = self.modules_dir / module_file

        # 添加模块头部信息
        header = f'''# =============================================================================
# {description}
# 模块文件: {module_file}
# 依赖工具: {', '.join(required_tools) if required_tools else '无'}
# 依赖模块: {', '.join(dependencies) if dependencies else '无'}
# 由 shell-tools-config-generator.py v2.1 自动生成
# =============================================================================

'''

        full_content = header + content

        if self.write_file(module_path, full_content):
            log_success(f"模块已生成: {module_file}")
            return True
        else:
            log_error(f"生成模块 {module_file} 失败")
            return False

    def write_debug_file(self, content: str) -> bool:
        """写入调试文件"""
        debug_path = self.debug_dir / "shell-tools-debug.zsh"

        if self.write_file(debug_path, content):
            log_success("调试模块已生成")
            return True
        else:
            log_error("生成调试模块失败")
            return False

    def write_main_config(self, content: str) -> bool:
        """写入主配置文件"""
        if self.write_file(self.main_config_file, content):
            log_success(f"主配置文件已生成: {self.main_config_file}")
            return True
        else:
            log_error("生成主配置文件失败")
            return False

    def update_zshrc_for_modular_config(self) -> bool:
        """更新.zshrc文件以使用模块化配置"""
        # 新的配置行
        new_config_lines = [
            "# Shell Tools Modular Configuration - Auto-generated by shell-tools-config-generator.py v2.1",
            "[[ -f ~/.oh-my-zsh/custom/shell-tools-main.zsh ]] && source ~/.oh-my-zsh/custom/shell-tools-main.zsh"
        ]

        if not self.zshrc_file.exists():
            log_warn(".zshrc文件不存在，创建新文件")
            with open(self.zshrc_file, 'w') as f:
                f.write('\n'.join(new_config_lines) + '\n')
            return True

        try:
            # 读取现有内容
            with open(self.zshrc_file, 'r') as f:
                lines = f.readlines()

            # 检查是否已经有新的配置
            has_new_config = any(new_config_lines[1] in line for line in lines)

            if not has_new_config:
                # 添加新的配置行
                lines.extend([line + '\n' for line in new_config_lines])

                with open(self.zshrc_file, 'w') as f:
                    f.writelines(lines)

                log_success("已更新.zshrc文件以使用模块化配置")
            else:
                log_info("Shell工具模块化配置引用已存在于.zshrc中")

            return True

        except Exception as e:
            log_error(f"更新.zshrc文件失败: {str(e)}")
            return False

    def get_file_stats(self) -> dict:
        """获取文件统计信息"""
        stats = {
            'main_config_exists': self.main_config_file.exists(),
            'modules_count': len(list(self.modules_dir.glob('*.zsh'))) if self.modules_dir.exists() else 0,
            'debug_exists': (self.debug_dir / "shell-tools-debug.zsh").exists(),
            'old_config_exists': self.old_config_file.exists(),
            'zshrc_exists': self.zshrc_file.exists()
        }
        return stats


# 全局文件管理器实例
_file_manager = None

def get_file_manager() -> FileManager:
    """获取全局文件管理器实例"""
    global _file_manager
    if _file_manager is None:
        _file_manager = FileManager()
    return _file_manager
